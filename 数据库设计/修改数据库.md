结合个人记账场景的**灵活性需求**（偶尔需修正旧记录）和**数据准确性**（预算/余额不偏差），建议采用「**允许修改1年内的历史记录，同步更新关联数据**」的方案——既避免完全禁止的刚性限制，又通过轻量化回溯逻辑保证数据一致，同时控制复杂度（远低于多用户场景）。


### 一、核心决策：允许修改1年内的历史记录
#### 1. 时间限制的合理性
- **1年期限**：个人记账中，修正旧记录的需求多集中在“近1年”（如记错3个月前的房租、漏记半年前的兼职收入），超过1年的记录基本已归档，修改意义小；  
- **禁止超1年**：避免因时间过久导致“回溯范围过大”（如改2年前的记录，需联动调整大量历史余额/预算数据），简化逻辑。

#### 2. 对比“禁止修改”的优势
- 更符合个人使用习惯：偶尔记错账（如金额输错、类别选错）是常见场景，完全禁止会导致“数据脏污”（明知错了却无法修正）；  
- 复杂度可控：个人场景下修改频率极低（每月可能1-2次），回溯逻辑的执行成本可忽略。


### 二、历史记录修改的核心逻辑设计（轻量化回溯）
修改旧记录时，需同步更新**账户余额**和**对应周期的预算执行数据**，避免统计偏差。核心逻辑分3步，不涉及复杂的“全量历史回溯”（仅调整关键节点数据）：


#### 步骤1：修改前的合法性校验
在执行修改前，先通过2层校验控制风险：
```java
/**
 * 校验是否允许修改历史记录
 * @param record 待修改的旧记录
 * @param currentUserId 当前用户ID
 */
private void validateModifyPermission(AccountRecord record, Long currentUserId) {
    // 1. 权限校验：确保是记录所属用户
    if (!record.getUserId().equals(currentUserId)) {
        throw new RuntimeException("无权修改他人记录");
    }
    // 2. 时间校验：仅允许修改1年内的记录
    LocalDate recordDate = record.getRecordDate();
    LocalDate oneYearAgo = LocalDate.now().minusYears(1);
    if (recordDate.isBefore(oneYearAgo)) {
        throw new RuntimeException("仅允许修改1年内的历史记录");
    }
    // 3. 状态校验：已删除的记录需先恢复，再修改
    if (record.getIsDeleted() == 1) {
        throw new RuntimeException("请先恢复已删除的记录，再进行修改");
    }
}
```


#### 步骤2：同步调整账户余额（关键！避免余额偏差）
旧记录的金额/类型修改会直接影响账户余额，无需回溯“从旧记录到当前的所有变动”（个人场景无并发，可简化为“直接调整当前余额”）：
```java
/**
 * 调整账户余额（基于旧记录与新记录的差额）
 * @param oldRecord 修改前的旧记录
 * @param newRecord 修改后的新记录
 */
@Transactional
private void adjustAccountBalance(AccountRecord oldRecord, AccountRecord newRecord) {
    // 1. 计算金额差额（新金额 - 旧金额）
    BigDecimal oldAmount = oldRecord.getAmount();
    BigDecimal newAmount = newRecord.getAmount();
    BigDecimal amountDiff = newAmount.subtract(oldAmount);

    // 2. 根据记录类型（支出/收入）调整差额方向
    BigDecimal balanceAdjustment;
    if (oldRecord.getType() == 1) { // 旧记录是支出（原余额减少）
        // 支出金额增加：余额需再减少（差额为正→调整为负）；支出金额减少：余额需增加（差额为负→调整为正）
        balanceAdjustment = amountDiff.negate();
    } else { // 旧记录是收入（原余额增加）
        // 收入金额增加：余额需再增加；收入金额减少：余额需减少
        balanceAdjustment = amountDiff;
    }

    // 3. 更新账户当前余额
    Account account = accountMapper.selectById(oldRecord.getAccountId());
    BigDecimal newBalance = account.getBalance().add(balanceAdjustment);
    account.setBalance(newBalance);
    accountMapper.updateById(account);

    // 4. 记录余额调整日志（便于追溯）
    accountLogMapper.insert(new AccountLog()
            .setAccountId(account.getId())
            .setUserId(oldRecord.getUserId())
            .setOperateType("MODIFY_HISTORY")
            .setContent(String.format("修改%d年%d月记录，余额调整：%s元（原余额：%s→新余额：%s）",
                    oldRecord.getRecordDate().getYear(),
                    oldRecord.getRecordDate().getMonthValue(),
                    balanceAdjustment,
                    account.getBalance().subtract(balanceAdjustment),
                    newBalance))
            .setOperateTime(LocalDateTime.now()));
}
```

**示例**：  
- 旧记录：2024年6月餐饮支出500元（账户余额减少500）；  
- 新记录：修改为300元（支出减少200）；  
- 差额计算：`300-500=-200`，支出类型调整为`+200`；  
- 账户当前余额直接加200元（无需回溯6月至今的所有余额变动）。


#### 步骤3：同步更新对应周期的预算执行数据
若修改的是**支出记录**（收入记录不影响预算），需重新计算该记录所属周期（如2024年6月）的对应类别预算进度：
```java
/**
 * 回溯更新预算执行数据
 * @param oldRecord 修改前的旧记录
 * @param newRecord 修改后的新记录
 */
private void rollbackAndRecalculateBudget(AccountRecord oldRecord, AccountRecord newRecord) {
    // 仅支出记录影响预算，收入记录跳过
    if (oldRecord.getType() != 1) {
        return;
    }

    // 1. 找到旧记录所属的预算周期（按记录日期匹配月度预算）
    LocalDate recordDate = oldRecord.getRecordDate();
    BudgetMain budgetMain = budgetMainMapper.selectByUserIdAndMonth(
            oldRecord.getUserId(),
            recordDate.getYear(),
            recordDate.getMonthValue()
    );
    if (budgetMain == null) { // 该月无预算，无需处理
        return;
    }

    // 2. 找到对应类别的子预算和执行记录
    BudgetSub budgetSub = budgetSubMapper.selectByMainIdAndCategoryId(
            budgetMain.getId(),
            oldRecord.getCategoryId()
    );
    if (budgetSub == null) { // 该类别无预算，无需处理
        return;
    }
    BudgetExecution execution = budgetExecutionMapper.selectBySubId(budgetSub.getId());

    // 3. 先回滚旧记录的预算影响（减去旧金额）
    BigDecimal usedAmountAfterRollback = execution.getUsedAmount().subtract(oldRecord.getAmount());
    // 4. 再叠加新记录的预算影响（加上新金额）
    BigDecimal newUsedAmount = usedAmountAfterRollback.add(newRecord.getAmount());

    // 5. 重新计算预算进度
    execution.setUsedAmount(newUsedAmount);
    execution.setRemainingAmount(budgetSub.getAmount().subtract(newUsedAmount));
    execution.setProgressRatio(newUsedAmount.divide(budgetSub.getAmount(), 4, RoundingMode.HALF_UP));
    execution.setIsOverspent(newUsedAmount.compareTo(budgetSub.getAmount()) > 0 ? 1 : 0);
    executionMapper.updateById(execution);
}
```

**示例**：  
- 旧记录：2024年6月餐饮支出500元（6月餐饮预算2000元，已用1500元）；  
- 修改后：支出300元；  
- 预算回溯：先减500（1500→1000），再加300（1000→1300）；  
- 最终6月餐饮预算进度：1300/2000=65%（原75%），超支状态同步更新。


#### 步骤4：记录修改日志（可追溯）
为避免“误修改后无法溯源”，需记录历史记录的修改痕迹：
```sql
-- 新增历史记录修改日志表（仅1张，轻量化）
CREATE TABLE `account_record_modify_log` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `record_id` bigint NOT NULL COMMENT '被修改的记录ID',
  `user_id` bigint NOT NULL COMMENT '操作人ID',
  `old_amount` decimal(12,2) NOT NULL COMMENT '修改前金额',
  `new_amount` decimal(12,2) NOT NULL COMMENT '修改后金额',
  `old_category_id` bigint NOT NULL COMMENT '修改前类别ID',
  `new_category_id` bigint NOT NULL COMMENT '修改后类别ID',
  `modify_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  `remark` varchar(200) DEFAULT NULL COMMENT '修改原因（如“金额输错”）',
  PRIMARY KEY (`id`),
  KEY `idx_record` (`record_id`) COMMENT '按记录ID查询修改历史'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='历史记录修改日志表';
```

修改时插入日志：
```java
// 插入修改日志
accountRecordModifyLogMapper.insert(new AccountRecordModifyLog()
        .setRecordId(oldRecord.getId())
        .setUserId(oldRecord.getUserId())
        .setOldAmount(oldRecord.getAmount())
        .setNewAmount(newRecord.getAmount())
        .setOldCategoryId(oldRecord.getCategoryId())
        .setNewCategoryId(newRecord.getCategoryId())
        .setRemark("用户手动修改历史记录")
        .setModifyTime(LocalDateTime.now()));
```


### 三、完整修改流程总结
1. **用户发起修改**：选择1年内的旧记录，修改金额/类别/日期（日期仍需在1年内）；  
2. **合法性校验**：权限、时间、记录状态校验；  
3. **事务内执行**：  
   - 调整账户当前余额（基于差额）；  
   - 回溯更新对应周期的预算执行数据；  
   - 更新记账记录本身（`account_record`）；  
   - 插入修改日志（`account_record_modify_log`）；  
4. **结果反馈**：返回修改后的记录和预算/余额变动结果。


### 四、方案优势与复杂度控制
#### 1. 优势
- **灵活性适配个人需求**：允许修正旧记录，避免数据脏污；  
- **数据一致性保障**：余额和预算同步更新，统计结果准确；  
- **可追溯性**：修改日志便于排查问题（如“为什么上个月预算进度变了”）。

#### 2. 复杂度控制
- **无需全量回溯**：仅调整当前余额和对应周期预算，不修改历史余额变动记录（`account_transaction`），逻辑简化80%；  
- **时间范围限制**：1年期限避免回溯范围过大，性能开销可忽略；  
- **无并发问题**：个人使用场景下，修改操作无并发冲突，无需加额外锁。


### 五、对比“禁止修改”的取舍
| 方案                | 灵活性 | 数据准确性 | 复杂度 | 个人场景适配度 |
|---------------------|--------|------------|--------|----------------|
| 允许修改1年记录     | 高     | 高（同步更新） | 低（轻量化回溯） | ★★★★★ |
| 仅允许修改1个月记录 | 中     | 高         | 低     | ★★★☆☆ |
| 禁止修改旧记录      | 低     | 中（可能脏数据） | 极低   | ★★☆☆☆ |

**结论**：“允许修改1年记录+同步更新关联数据”是个人场景下的最优解——既满足实际使用中的修正需求，又通过轻量化设计控制复杂度，无需额外维护成本。